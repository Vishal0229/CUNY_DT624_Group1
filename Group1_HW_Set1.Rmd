---
title: "CUNY DT 624---Summer 2020"
subtitle: "Homework Set 1"
author: "Group 1: Avraham Adler, Vishal Arora, Gabrielle Bartomeo, Samuel Bellows, Austin Chan"
date: "Summer 2020"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Question HA 2.1
## Questions
Use the help function to explore what the series gold, woolyrnq and gas
represent.
 a. Use `autoplot()` to plot each of these in separate plots.
 b. What is the frequency of each series? Hint: apply the `frequency()` function.
 c. Use `which.max()` to spot the outlier in the gold series. Which observation
 was it?
 
## Answers
### Help Functions
```{r Q1setup, echo=TRUE, warning=FALSE, out.width="100%", message=FALSE}
library(fpp2)
library(httr)
```

Using the help function to know more about the various datasets like a short
description about the dataset, the format of the dataset---which in this case is
Time Series data for all three, what is the source of the data, and an example
of how to display the data to learn about it using the `tsdisplay` function.           

```{r Q1help}
help(gold)
help("woolyrnq")
help("gas")
```

According to the help function, the datasets are described as so:

gold - This dataset represents the daily morning gold prices in US dollars from January 1st, 1985 to March 31st, 1989.

woolyrnq - This dataset represents the quarterly production of woollen yarn in Australia in tons from March 1965 to September 1994.

gas - This dataset represents the Australian monthly gas prodcution from 1956 to 1995.

### Part a
Using the `autoplot` function can give us a graphic disply of `ts` datasets.
Looking at the graphs we can see if there is any trend, seasonality, or other
cyclical patterns in the datasets which can help us in selecting our model for
prediction.                              

```{r Q1autoplot}
autoplot(gold)
autoplot(woolyrnq)
autoplot(gas)
```

### Part b
Using the `frequency` function, we find that Gold has annual frequency, Woolrnq
has quarterly frequency, and Gas has monthly frequency.
```{r Q1freuency}
frequency(gold)
frequency(woolyrnq)
frequency(gas)
```

### Part c

Using the `which.max()` function gives us the index of the outlier with maximum value. It is important to note that the `which.max()` function does not return the actual max value, but the index in the vector where the max value is located. After plugging in the `which.max()` index value into the time series vector, we get the true maximum value, which is 593.7.

```{r Q1whichmax}
which.max(gold)
gold[which.max(gold)]
```

# Question HA 2.3
## Questions
Download some monthly Australian retail data from the
[book website](http://otexts.com/fpp2/extrafiles/tute1.csv). These represent
retail sales in various categories for different Australian states, and are
stored in a MS-Excel file.
 
 a. You can read the data into R with the following script:
 ```
 retaildata <- readxl::read_excel("retail.xlsx", skip=1)
 ```
 The second argument (skip=1) is required because the Excel sheet has two header
 rows.

 b. Select one of the time series as follows (but replace the column name with
 your own chosen column):
 ```
 myts <- ts(retaildata[,"A3349873A"], frequency=12, start=c(1982,4))
 ```
 
 c. Explore your chosen retail time series using the following functions:
     ```autoplot(), ggseasonplot(), ggsubseriesplot(), gglagplot(), ggAcf()```
    Can you spot any seasonality, cyclicity and trend? What do you learn about
    the series?
    
## Answers
### Part a
Using the `httr` package's `GET` function to download the retail.xlsx file to
a local directory and then using the `read_xlsx` function to read the xlsx
skipping the first row into a R Dataframe object.
```{r Q2a}
url <- "https://otexts.com/fpp2/extrafiles/retail.xlsx"
GET(url, write_disk("retail.xlsx", overwrite=TRUE))
retaildata <- readxl::read_xlsx("retail.xlsx", skip=1)
```

### Part b
```{r Q2b}
# choosing column 'A3349721R'
myts <- ts(retaildata[, "A3349721R"], frequency = 12, start = c(1982, 1),
           end = c(2005, 6))
head(myts)
tail(myts, 6)
```

### Part c
Using the `autoplot` function on a `ts` dataset, we can see that there is indeed
a trend and seasonality in the graph.                                            

```{r Q2c1}
autoplot(myts)
```

Using the `ggseasonplot` function, one can confirm what we deduced from the
above plot that there is slight seasonlity pattern also in the data. Thus
September is the peak and March is the trough season.
```{r Q2c2}
ggseasonplot((myts))
```

Using `subseriesplot` we can see the seasonality for each month for the time
span of time series. We can clearly see that September is the peak and March and
November are the troughs.           
```{r Q2c3}
ggsubseriesplot(myts)
```

A lag plot shows the scatter plots for each month in which all the graphs show
linearity. This suggests that a strong autocorrelations exits.                                 
```{r Q2c4}
gglagplot(myts)
```

Using the `ggACF` function to plot ACF graphs with differrent lag periods shows
that there exists strong autocorrelations. We can also see that with the
increase in lag period the graphs show decreasing positive values. With
increasing lag periods in the second graph we can also see a slight seasonal
pattern.                         

```{r Q2c5}
ggAcf(myts, lag = 12)

ggAcf(myts, lag = 30)

```

### Summary
As we can clearly see that out data in second questions has a positive trend
with a slight seasonality and with no cyclic patterns.
This can be corroborated by plotting using the decompose function and then
autoplotting.              

```{r Q2Summary}
decmyts <-decompose(myts)
autoplot(decmyts, type="multiplicative")
```

# Question HA 6.2
## Question
The `plastics` data set consists of the monthly sales (in thousands) of product
A for a plastics manufacturer for five years.

 a. Plot the time series of sales of product A. Can you identify seasonal
 fluctuations and/or a trend-cycle?
 b. Use a classical multiplicative decomposition to calculate the trend-cycle
 and seasonal indices.
 c. Do the results support the graphical interpretation from part a?
 d. Compute and plot the seasonally adjusted data.
 e. Change one observation to be an outlier (e.g., add 500 to one observation),
 and recompute the seasonally adjusted data. What is the effect of the outlier?
 f. Does it make any difference if the outlier is near the end rather than in
 the middle of the time series?
 
## Answers
### Part a
```{r Q62a}
autoplot(plastics)
```

The graphs shows clear seasonality. The winter months have low values, which
climb in the spring and summer, and then fall during fall. There is also a
long-term increasing secular trend in the sales figures. There is too little
data to determine if this increasing trend is part of a larger cycle. The peak
in the last year (the years are denoted 1--5 in the dataset) is relatively
lower than prior peak increases have been, which may indicate the turning of
a cycle. However, one to two more years of data would be necessary to make a
specific determination.

### Part b
This data has monthly frequency, so \(m = 12\) and \(\hat{T}_n\) should be
calculated as a 2x12-period moving average.
```{r 62b_1}
Tn <- ma(plastics, order = 12, centre = TRUE)
```

Classical multiplicative decomposition detrends by dividing out the MA component.
```{r 62b_2}
detrendPlastics <- plastics / Tn
```

Classical decomposition adjusts for seasonality by calculating \(\hat{S}_n\),
the average value per cycle---here monthly---and then subtracting it for
additive, or dividing it out for multiplicative, from the detrended series.
```{r 62b_3}
# Preallocate your data structures when you can: RInferno
Sn <- double(12)
# This can be vectorized using data.table or dplyr, but is short enough that
# the simple for loop is easiest to understand and implement.
for (i in seq_len(12)) {
    Sn[i] <- mean(detrendPlastics[cycle(detrendPlastics) == i], na.rm = TRUE)
}
```

The raw values need to be adjusted so that their sum equals \(m\), which is 12
in this case.
``` {r 62b_4}
Sn <- 12 * Sn / sum(Sn)
```

The random component of the times series, \(\hat{R}_n\) is calculated in 
classical multiplicative decomposition as the quotient of the raw values with
the product of the trend-cycle and seasonal components.
```{r 62b_5}
Rn <- plastics / (Tn * Sn)
```

We can check these results by comparing them to the output of the `decompose`
function from the `stats` package, which does all of this automatically.
```{r 62b_6}
DecomPlastics <- decompose(plastics, type = 'multiplicative')
all.equal(DecomPlastics$trend, Tn)
all.equal(DecomPlastics$figure, Sn)
all.equal(DecomPlastics$random, Rn)
```

While graphical output will wait until part d, below are \(\hat{S}_n,
\hat{T}_n\), and \(\hat{R}_n\).
```{r 62b_7}
Sn
Tn
```

### Part c.
As surmised above, there is unmistakeably clear seasonality shown in
\(\hat{S}_n\). Moreover, there is also a clear increasing trend shown in
\(\hat{T}_n\). Lastly, the trend element shows a peak around February \& March
of year 5. This implies that instead of a pure upwards trend there may be a
longer-term cycle. However, whether that is noise or signal requires more data.
Regardless, the multiplicative decomposition in part b clearly **supports** the
graphical interpretation of part a.

### Part d.
The results will be graphically displayed using `autoplot` from `ggplot2`.
```{r Q62d_1}
autoplot(DecomPlastics)
```

The seasonally-adjusted data is \(\hat{T}_n\hat{R}_n\) which is plotted below.
```{r Q62d_2}
plot(Tn * Rn, ylab = "Seasonally-Adjusted")
```

### Part e.
```{r Q62e_1}
plastics2 <- plastics
plastics2[[26]] <- plastics2[[26]] + 500
Tn2 <- ma(plastics2, order = 12, centre = TRUE)
detrendPlastics2 <- plastics2 / Tn2
Sn2 <- double(12)
for (i in seq_len(12)) {
    Sn2[i] <- mean(detrendPlastics2[cycle(detrendPlastics2) == i], na.rm = TRUE)
}
Sn2 <- 12 * Sn2 / sum(Sn2)
plot(Sn, type = 'l')
lines(Sn2, col = 'blue')
autoplot(decompose(plastics2, type = 'multiplicative'))
```

As can be seen from the plots above, the adding of an outlier to February in the
middle of the time series gives a "bump" to that period's entry in the
seasonality index and has an effect on the moving average so long as it is
within the window. However, the overall shape and scale of the decompositions
are very similar, indicating some level of robustness to a one-time outlier

### Part f.
```{r Q62f_1}
plastics3 <- plastics
plastics3[[2]] <- plastics2[[2]] + 500
Tn3 <- ma(plastics3, order = 12, centre = TRUE)
detrendPlastics3 <- plastics3 / Tn3
Sn3 <- double(12)
for (i in seq_len(12)) {
    Sn3[i] <- mean(detrendPlastics3[cycle(detrendPlastics3) == i], na.rm = TRUE)
}
Sn3 <- 12 * Sn3 / sum(Sn3)
plot(Sn, type = 'l')
lines(Sn2, col = 'blue')
lines(Sn3, col = 'purple')
autoplot(decompose(plastics3, type = 'multiplicative'))
```

Here, the outlier was added to the first February. In this case it has almost
no effect at all, as that is outside the acceptable window for a 2x12 moving
average. In this case, interestingly, one of the known shortcomings of
classical decomposition---its inability to process the ends of the time
series---here becomes valuable!

# Question KJ 3.1
## Question
The UC Irvine Machine Learning Repository[^a] contains a data set related
to glass identification. The data consist of 214 glass samples labeled as one
of seven class categories. There are nine predictors, including the refractive
index and percentages of eight elements: Na, Mg, Al, Si, K, Ca, Ba, and Fe.
The data can be accessed via:
```{r QKJ31}
library(mlbench)
data(Glass)
str(Glass)
```

 (a) Using visualizations, explore the predictor variables to understand their
 distributions as well as the relationships between predictors.
 (b) Do there appear to be any outliers in the data? Are any predictors skewed?
 (c) Are there any relevant transformations of one or more predictors that might
 improve the classification model?
 
[^a]: http://archive.ics.uci.edu/ml/index.html
 
## Answer
### Part (a)
The first step is to plot the predictors on their native scale. A call to `plot`
will produce a set of scatterplots for each variable against the other. Since
there are alot of plots and 214 observations in each, the period will be used
for points instead of the default open circle.
```{r Q31a1}
plot(Glass, pch = ".")
```